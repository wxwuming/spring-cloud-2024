## 基本数据类型

1. **整型（Integer Types）**：用于表示整数值，包括以下四种类型：
   - `byte`：8位有符号整数，范围为 -128 到 127。
   - `short`：16位有符号整数，范围为 -32768 到 32767。
   - `int`：32位有符号整数，范围为 -2147483648 到 2147483647。
   - `long`：64位有符号整数，范围为 -9223372036854775808 到 9223372036854775807。
2. **浮点型（Floating-Point Types）**：用于表示带有小数点的数值，包括两种类型：
   - `float`：32位单精度浮点数，范围为大约 ±3.40282347 x 10^38，精度约为 6-7 位小数。
   - `double`：64位双精度浮点数，范围为大约 ±1.79769313486231570 x 10^308，精度约为 15 位小数。
3. **字符型（Character Type）**：
   - `char`：16位 Unicode 字符，范围为 '\u0000'（即 0）到 '\uffff'（即 65535）。
4. **布尔型（Boolean Type）**：
   - `boolean`：表示 true 或 false。

这些基本数据类型在 Java 中是原生支持的，除此之外，Java 还支持引用数据类型，如类、接口、数组等。

## 堆栈

"堆"（Heap）和"栈"（Stack）是计算机内存中两种不同的存储方式，它们在内存管理和数据存储方面有着不同的特点。

1. **栈（Stack）**：
   - 栈是一种线性数据结构，它具有后进先出（LIFO）的特性，也就是最后入栈的元素最先出栈。
   - 栈主要用于程序的函数调用和局部变量的存储。
   - 当一个函数被调用时，该函数的局部变量和参数会被存储在栈内存中。
   - 栈的大小在编译时就被确定，通常比较小，因此对栈的操作速度比较快。
   - 栈内存的分配和释放是自动的，由编译器管理。
2. **堆（Heap）**：
   - 堆是一种动态分配的内存，它的大小不固定，可以根据需要动态增长或缩小。
   - 堆内存通常用于存储程序运行时动态分配的数据，例如通过 `malloc()`、`new` 等分配的内存。
   - 堆的分配和释放需要手动进行，程序员需要负责在不再需要时释放堆内存，否则会造成内存泄漏。
   - 堆的存储空间通常比栈大，并且由于动态分配的特性，其分配和释放速度可能较慢。

在程序中，栈和堆都有各自的使用场景和适用性。栈主要用于存储局部变量和函数调用，它的管理方式比较简单，速度也比较快；而堆主要用于存储动态分配的数据，它的灵活性更高，但需要程序员自行管理内存的分配和释放。

## JDK结构

JDK -> JRE + 开发工具

JRE -> JVM + 运行时类库

## Java内存模型


Java内存模型（Java Memory Model，JMM）定义了Java虚拟机（JVM）如何管理计算机内存以及线程之间如何共享数据的规范。它主要关注多线程并发编程中的内存访问和同步操作，确保在多线程环境中，共享数据的可见性、有序性和一致性。

以下是Java内存模型的主要特性和概念：

1. **主内存（Main Memory）**：主内存是所有线程共享的内存区域，其中包含了Java对象实例、类信息、静态变量等。
2. **工作内存（Working Memory）**：每个线程都有自己的工作内存，用于存储主内存中的部分数据的副本。线程对数据的操作都在工作内存中进行。
3. **内存间交互操作**：JMM规定了一组操作，用于线程之间的数据交互，主要是通过`volatile`关键字、`synchronized`关键字、`final`关键字等来实现。
4. **原子性（Atomicity）**：JMM保证了某些操作的原子性，即这些操作要么全部执行成功，要么全部失败，不会出现部分执行的情况。
5. **可见性（Visibility）**：JMM确保一个线程对共享变量的修改对于其他线程是可见的，通过`volatile`、`synchronized`等机制来保证可见性。
6. **有序性（Ordering）**：JMM保证程序执行的顺序在一定程度上是有序的，尽管现代处理器和编译器可能会对指令重排序进行优化，但是JMM定义了一些规则来限制这种重排序行为。
7. **happens-before关系**：在JMM中，happens-before关系描述了两个操作之间的顺序关系。如果一个操作happens-before另一个操作，那么前一个操作的结果对于后一个操作是可见的。
8. **final域的内存语义**：JMM对于final域有特殊的内存语义，确保在对象发布过程中，被发布对象的final域在构造函数结束前的写入操作对于其他线程是可见的。

Java内存模型的正确理解和应用对于编写正确、高效、并发安全的多线程程序至关重要。程序员需要了解JMM的各种规则和机制，并根据需求合理地使用`volatile`、`synchronized`、`final`等关键字，以及其他并发工具，来保证程序的正确性和性能。

## JVM内存模型

Java Virtual Machine (JVM) 内存模型定义了 Java 程序在运行时所使用的内存结构和管理方式。它主要包括以下几个部分：

1. **程序计数器 (Program Counter)**： 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在多线程环境下，每个线程都有自己的程序计数器，互不影响。
2. **Java 虚拟机栈 (JVM Stack)**： 每个线程在创建时都会被分配一个 Java 虚拟机栈。栈中存放着方法的栈帧，每个方法的调用都会创建一个栈帧，栈帧中存放着局部变量表、操作数栈、动态链接、方法出口等信息。栈帧的大小在编译时就已经确定。
3. **本地方法栈 (Native Method Stack)**： 与 Java 虚拟机栈类似，不同之处在于本地方法栈为 Native 方法服务。
4. **Java 堆 (Java Heap)**： Java 堆是 Java 虚拟机中最大的一块内存区域，用于存放对象实例。在堆中可以被所有线程共享，因此在多线程环境下需要注意线程安全的问题。
5. **方法区 (Method Area)**： 方法区用于存放类信息、常量、静态变量、即时编译器编译后的代码等数据。在 Java 8 及之前的版本中，方法区被称为永久代 (Permanent Generation)，但在 Java 8 中已经被移除，并改为使用元空间 (Metaspace) 代替。**运行时常量池 (Runtime Constant Pool)**： 运行时常量池是方法区的一部分，用于存放编译期生成的字面量和符号引用。在类加载后，将常量池中的符号引用解析为直接引用。

这些内存区域的不同特点和作用，为 Java 程序的运行提供了必要的支持。在实际编程中，合理地管理和利用这些内存区域，可以提高程序的性能和稳定性。

## 红黑树

红黑树是一中自平衡的二叉查找树：

1. 根节点是黑色，叶节点是不储存数据的黑色空节点
2. 任何相邻的两个节点都不能同时为红色
3. 任意节点到其所在分支的叶节点中黑色节点的数量是相同的

## HashMap特性及实现原理

HashMap 是 Java 中的一个非常重要的数据结构，它实现了 Map 接口，提供了键值对的存储和检索功能。下面我将介绍 HashMap 的特性及其实现原理：

### 特性：

1. **键值对存储**：HashMap 存储的是键值对，每个键都是唯一的，可以通过键来获取对应的值。
2. **高效的查找**：HashMap 通过哈希表实现，具有高效的查找性能。在大多数情况下，查找、插入和删除操作的时间复杂度为 O(1)。
3. **无序性**：HashMap 内部的数据是无序存储的，即不保证遍历顺序与插入顺序或者其他顺序一致。
4. **允许空键空值**：HashMap 允许键和值都为 null，但是同一个 HashMap 中只能有一个键为 null。
5. **线程不安全**：HashMap 不是线程安全的，如果多个线程同时访问 HashMap 并且至少有一个线程修改了结构（增加或删除元素），则必须通过外部同步手段来保证线程安全，或者使用线程安全的 ConcurrentHashMap。

### 实现原理：

1. **哈希表**：HashMap 内部使用一个数组（称为桶或者表）来存储元素，每个元素存储在数组的一个位置上。数组的每个位置称为一个桶，每个桶可以存储一个或多个元素，这取决于哈希冲突的情况。
2. **哈希函数**：HashMap 使用哈希函数将键映射到数组的索引位置上。理想情况下，哈希函数可以将不同的键均匀地分布到数组的不同位置上，减少哈希冲突的概率。
3. **解决哈希冲突**：由于哈希函数的映射不可能完全避免冲突，因此 HashMap 需要解决哈希冲突的问题。常见的解决冲突的方式有两种：链地址法（Separate Chaining）和开放地址法（Open Addressing）。
4. **链地址法**：在链地址法中，每个桶存储一个链表或者红黑树（JDK8 中采用红黑树来优化链表），具有相同哈希值的键值对会存储在同一个桶中。当发生哈希冲突时，新的键值对会被添加到链表或者树的末尾。
5. **扩容与重新哈希**：当 HashMap 中的元素数量超过了阈值（负载因子乘以数组大小），HashMap 会进行扩容操作。扩容会创建一个新的更大的数组，并将所有的键值对重新哈希到新的数组中，这样可以减少哈希冲突的概率。

总的来说，HashMap 通过哈希表实现了高效的键值对存储和检索，通过合理的哈希函数和解决冲突的策略，保证了性能的稳定性和可靠性。

## Spring Bean的生命周期

作用域：

singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
prototype : 每次请求都会创建一个新的 bean 实例。
request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。
global-session： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。

- 实例化 Instantiation
- 属性赋值 Populate
- 初始化 Initialization
- 销毁 Destruction 容器关闭时销毁

## Java垃圾回收机制

自动监测对象是否超出作用域而达到自动回收内存

# JVM

## Oracle JDK 和Open JDK 有什么区别

Oracle JDK 是由 Oracle 公司提供的，包含了一些商业特性和支持服务；而 OpenJDK 是一个由社区驱动的开源项目，提供了免费的Java开发工具。

## JDK、JRE、JVM的关系

**JDK** = JRE + 开发工具集（例如Javac编译工具等）

**JRE** = JVM + Java SE 标准类库

## JVM跨语言的平台

不论程序通过何种代码编写，只关心字节码文件

Java不是最强大的语言，但是JVM是最强大的虚拟机

